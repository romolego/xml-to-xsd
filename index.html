<!DOCTYPE html>

<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>XML → XSD</title>
<style>
  :root{
    --bg:#ffffff; --fg:#0f1720; --muted:#5a6a7a; --line:#e6e9ee;
    --badge:#f4f6fa; --hover:rgba(15,23,32,.06);
    --shadow:0 1px 2px rgba(0,0,0,.06),0 4px 18px rgba(0,0,0,.05);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", Consolas, "Liberation Mono","Courier New", monospace;
    --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    --accent:#0ea5e9; --ok:#059669; --warn:#b91c1c;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 var(--sans)}
  .container{max-width:1100px;margin:0 auto;padding:16px 16px 80px}

.controls{border:1px solid var(--line);border-radius:12px;background:#fff;box-shadow:var(--shadow);
padding:12px;margin:0 0 12px 0;display:flex;flex-direction:column;gap:10px}
.drop{border:1px dashed #cfd6df;border-radius:10px;padding:12px 16px;text-align:center;color:var(--muted);
cursor:pointer;background:#fbfcff}
.drop.drag{border-color:var(--accent);background:rgba(14,165,233,.06)}
.opts{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
.hint{color:var(--muted);font-size:12px}

.status{display:flex;gap:8px;align-items:center;flex-wrap:wrap;border-bottom:1px solid var(--line);padding-bottom:8px;margin:12px 0}
.badge{background:var(--badge);color:#223;border:1px solid #e9edf3;padding:4px 8px;border-radius:999px;font-size:12px}

.grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;align-items:start}

.card{border:1px solid var(--line);border-radius:12px;background:#fff;box-shadow:var(--shadow);display:flex;flex-direction:column}
.card h2{margin:0;padding:10px 12px;border-bottom:1px solid var(--line);font-size:13px;font-weight:600}
.card .body{padding:10px 12px;display:flex;flex-direction:column;gap:8px;overflow-wrap:anywhere;word-break:break-word}
.card .body *{max-width:100%;overflow-wrap:anywhere;word-break:break-word}

textarea{width:100%;border:1px solid var(--line);border-radius:10px;padding:10px;resize:vertical;font-family:var(--mono);font-size:12px;min-height:0}
.io-area{height:380px}
/* подсветка при DnD на окно XML */
#xml.dragover{outline:2px dashed var(--accent); outline-offset:4px; background:#f0f9ff}

.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:8px 0 0}
.btn{border:1px solid #cfd6df;background:#fafbfd;color:#203040;padding:8px 12px;border-radius:8px;cursor:pointer}
.btn.success{background:#ecfdf5;border-color:#a7f3d0;color:#065f46}
.btn.ghost{background:#fff;border-color:#e5ebf2}
.btn:disabled{opacity:.55;cursor:not-allowed}
.btn:active{transform:translateY(1px)}

.err{color:var(--warn);font-size:12px;margin-top:6px;display:none}
.ok{color:var(--ok);font-size:12px;margin-top:6px;display:none}

.progress-wrap{height:3px;background:transparent;position:relative;overflow:hidden;display:none;margin-top:8px}
.progress{position:absolute;inset:0 100% 0 0;background:linear-gradient(90deg,#bfe7d8,#6fbba0);animation:load 1.2s linear infinite}
@keyframes load{0%{inset:0 100% 0 0}50%{inset:0 30% 0 0}100%{inset:0 100% 0 0}} </style>

</head>
<body>
<div class="container">

  <!-- верхняя панель (оставляем как было) -->

  <section class="controls">
    <label class="drop" id="dropzone">
      <input id="file" type="file" accept=".xml,text/xml,application/xml" style="display:none"/>
      Перетащите XML сюда или кликните для выбора файла
    </label>
    <div class="opts">
      <span class="hint">Эвристики типов:</span>
      <label class="hint"><input type="checkbox" id="tBool" checked> boolean</label>
      <label class="hint"><input type="checkbox" id="tInt" checked> integer</label>
      <label class="hint"><input type="checkbox" id="tDec" checked> decimal</label>
      <label class="hint"><input type="checkbox" id="tDate" checked> date</label>
      <label class="hint"><input type="checkbox" id="tDT" checked> dateTime</label>
      <label class="hint"><input type="checkbox" id="tNil" checked> пустые → nillable</label>
    </div>
  </section>

  <div class="status">
    <span class="badge" id="badgeFile">Файл: —</span>
    <span class="badge" id="badgeRoot">Корневой элемент: —</span>
    <span class="badge" id="badgeNodes">Тегов: 0</span>
    <span class="badge" id="badgeAttrs">Атрибутов: 0</span>
    <span class="badge" id="badgeDepth">Глубина: 0</span>
    <div class="progress-wrap" id="progressWrap"><div class="progress"></div></div>
  </div>

  <div class="grid">
    <!-- левая колонка -->
    <section class="card">
      <h2>Входной XML</h2>
      <div class="body">
        <textarea id="xml" class="io-area" placeholder="Вставьте XML сюда…" spellcheck="false"></textarea>

    <div class="row">
      <button id="btnClear" class="btn ghost">Очистить</button>
      <button id="btnParse" class="btn" disabled>Разобрать XML</button>
      <button id="btnGen" class="btn success" disabled>Сгенерировать XSD</button>
    </div>

    <div id="err" class="err"></div>
    <div id="ok" class="ok"></div>
  </div>
</section>

<!-- правая колонка -->
<section class="card">
  <h2>XSD</h2>
  <div class="body">
    <textarea id="xsd" class="io-area" placeholder="Здесь появится XSD…" spellcheck="false"></textarea>
    <div class="row">
      <button id="btnCopy" class="btn" disabled>Копировать</button>
      <button id="btnDownload" class="btn" disabled>Скачать .xsd</button>
    </div>
  </div>
</section>

  </div>
</div>

<script>
(() => {
  const $ = sel => document.querySelector(sel);

  const els = {
    drop: $('#dropzone'), file: $('#file'),
    btnClear: $('#btnClear'), btnParse: $('#btnParse'), btnGen: $('#btnGen'),
    xml: $('#xml'), xsd: $('#xsd'),
    btnCopy: $('#btnCopy'), btnDownload: $('#btnDownload'),
    err: $('#err'), ok: $('#ok'),
    badgeFile: $('#badgeFile'), badgeRoot: $('#badgeRoot'), badgeNodes: $('#badgeNodes'),
    badgeAttrs: $('#badgeAttrs'), badgeDepth: $('#badgeDepth'),
    progressWrap: $('#progressWrap'),
    tBool: $('#tBool'), tInt: $('#tInt'), tDec: $('#tDec'), tDate: $('#tDate'), tDT: $('#tDT'), tNil: $('#tNil')
  };

  let xmlText = '';
  let xmlDoc = null;
  let model = null;
  const opt = { bool:true, int:true, dec:true, date:true, dt:true, nil:true };

  function showErr(msg){ els.err.textContent = msg; els.err.style.display='block'; els.ok.style.display='none'; }
  function showOk(msg){ els.ok.textContent = msg; els.ok.style.display='block'; els.err.style.display='none'; }
  function clearMsg(){ els.err.style.display='none'; els.ok.style.display='none'; }
  function setBusy(b){ els.progressWrap.style.display = b ? 'block':'none'; }

  const TT = { BOOL:'xs:boolean', INT:'xs:integer', DEC:'xs:decimal', DATE:'xs:date', DT:'xs:dateTime', STR:'xs:string' };
  const rx = {
    bool: /^(?:true|false|0|1)$/i,
    int: /^[-+]?\d+$/,
    dec: /^[-+]?(?:\d+\.\d+|\d+,\d+)$/,
    date: /^\d{4}-\d{2}-\d{2}$/,
    dt: /^\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}(:\d{2}(?:\.\d{1,6})?)?(?:Z|[+\-]\d{2}:\d{2})?$/
  };
  const esc = s => String(s).replace(/[<&>"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;'}[c]));

  function guess(v){
    if (v == null) return TT.STR;
    const s = String(v).trim();
    if (!s) return TT.STR;
    if (opt.bool && rx.bool.test(s)) return TT.BOOL;
    if (opt.int && rx.int.test(s)) return TT.INT;
    if (opt.dec && rx.dec.test(s)) return TT.DEC;
    if (opt.dt && rx.dt.test(s)) return TT.DT;
    if (opt.date && rx.date.test(s)) return TT.DATE;
    return TT.STR;
  }
  function unify(a,b){
    if (!a) return b||TT.STR; if (!b) return a; if (a===b) return a;
    if ((a===TT.INT && b===TT.DEC) || (a===TT.DEC && b===TT.INT)) return TT.DEC;
    if ((a===TT.DATE && b===TT.DT) || (a===TT.DT && b===TT.DATE)) return TT.DT;
    const order=[TT.BOOL,TT.INT,TT.DEC,TT.DATE,TT.DT,TT.STR];
    return order[Math.max(order.indexOf(a), order.indexOf(b))];
  }

  class NodeInfo{
    constructor(name, path){
      this.name = name; this.path = path;
      this.count = 0;
      this.children = new Map();
      this.appearanceOrder = [];
      this.appearanceSet = new Set();
      this.attrs = new Map();
      this.textType = null;
      this.nillable = false;
      this.maxDepth = 1;
      this.seqCount = 0;
      this.emptySeqCount = 0;
      this.maxSeqLen = 0;
      this.edges = new Map();
      this.hasSplitRuns = false;
    }
  }

  function rememberAppearance(info, name){
    if (!info.appearanceSet.has(name)){
      info.appearanceSet.add(name);
      info.appearanceOrder.push(name);
    }
  }

  function walk(node, path, model){
    const name = node.nodeName;
    const curr = path ? path + '/' + name : '/' + name;
    let info = model.get(curr);
    if(!info){ info = new NodeInfo(name, curr); model.set(curr, info); }
    info.count++;

    if (node.attributes && node.attributes.length){
      for(const a of node.attributes){
        const isNilAttr = (a.namespaceURI === 'http://www.w3.org/2001/XMLSchema-instance' && a.localName === 'nil') || a.name === 'xsi:nil';
        if (isNilAttr){
          if (/^(?:true|1)$/i.test(String(a.value||''))){ info.nillable = true; }
          continue;
        }
        const prev = info.attrs.get(a.name) || {type:null,count:0,seenEmpty:false};
        prev.type = unify(prev.type, guess(a.value));
        prev.count += 1;
        if ((a.value??'').trim()===''){ prev.seenEmpty = true; }
        info.attrs.set(a.name, prev);
      }
    }

    const elsKids = [];
    let hasTextHere = false;
    for(const ch of node.childNodes){
      if (ch.nodeType===1){
        elsKids.push(ch);
      } else if (ch.nodeType===3){
        const t = ch.nodeValue.trim();
        if (t!==''){ info.textType = unify(info.textType, guess(t)); hasTextHere = true; }
        else if (opt.nil){ info.nillable = true; }
      }
    }

    if (elsKids.length){
      const perName = new Map();
      for (const e of elsKids){
        const n = e.nodeName;
        perName.set(n, (perName.get(n)||0)+1);
      }
      for (const [childName, meta] of info.children.entries()){
        if (!perName.has(childName)){
          meta.min = 0;
        }
      }
      for (const [n,c] of perName){
        let meta = info.children.get(n);
        if (!meta){
          meta = {min:c,max:c};
          info.children.set(n, meta);
          rememberAppearance(info, n);
        } else {
          meta.min = Math.min(meta.min, c);
          meta.max = Math.max(meta.max, c);
        }
      }
      info.seqCount += 1;
      info.maxSeqLen = Math.max(info.maxSeqLen, elsKids.length);
      const runs = [];
      let prevName = null;
      for (const e of elsKids){
        const name = e.nodeName;
        if (runs.length===0 || prevName !== name){
          runs.push({name,count:1});
        } else {
          runs[runs.length-1].count += 1;
        }
        prevName = name;
      }
      if (!info.hasSplitRuns){
        const seen = new Set();
        for (const r of runs){
          if (seen.has(r.name)){ info.hasSplitRuns = true; break; }
          seen.add(r.name);
        }
      }
      let lastName = null;
      for (const e of elsKids){
        const name = e.nodeName;
        if (name !== lastName && lastName !== null){
          if (!info.edges.has(lastName)) info.edges.set(lastName, new Set());
          info.edges.get(lastName).add(name);
        }
        lastName = name;
      }
      for (const e of elsKids){
        walk(e, curr, model);
        const child = model.get(curr + '/' + e.nodeName);
        info.maxDepth = Math.max(info.maxDepth, (child?.maxDepth||1)+1);
        rememberAppearance(info, e.nodeName);
      }
    } else {
      for (const meta of info.children.values()) meta.min = 0;
      info.seqCount += 1;
      info.emptySeqCount += 1;
      info.maxDepth = Math.max(info.maxDepth, 1);
    }
  }

  function buildModel(doc){
    const root = doc?.documentElement;
    if (!root){ throw new Error('Документ не содержит корневой элемент.'); }
    const m = new Map();
    walk(root, '', m);
    return m;
  }

  function emitXsd(model){
    if (!model || model.size===0){ throw new Error('Модель пустая — нечего генерировать.'); }
    const first = model.values().next().value;
    if (!first){ throw new Error('Не удалось определить корневой элемент.'); }
    const root = first.path;
    const lines = [];
    lines.push('<?xml version="1.0" encoding="UTF-8"?>');
    lines.push('<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">');
    emitElement(root, 1, null);
    lines.push('</xs:schema>');
    return lines.join('\n');

    function emitElement(path, ind, occurs){
      const info = model.get(path);
      const pad = '  '.repeat(ind);
      const occursStr = occurs ? ` minOccurs="${occurs.min}" maxOccurs="${occurs.max}"` : '';
      const nilAttr = (opt.nil && info.nillable) ? ' nillable="true"' : '';
      const hasKids = info.children.size>0;
      const hasAttrs = info.attrs.size>0;
      const hasText = !!info.textType;
      if (!hasKids && !hasAttrs){
        const base = info.textType || TT.STR;
        lines.push(`${pad}<xs:element name="${esc(info.name)}"${occursStr}${nilAttr} type="${base}"/>`);
        return;
      }
      lines.push(`${pad}<xs:element name="${esc(info.name)}"${occursStr}${nilAttr}>`);
      if (hasKids){
        const complexFlags = [];
        if (hasText){ complexFlags.push('mixed="true"'); }
        lines.push(`${pad}  <xs:complexType${complexFlags.length ? ' ' + complexFlags.join(' ') : ''}>`);
        emitChildren(path, info, ind+2);
        emitAttributes(info, ind+2);
        lines.push(`${pad}  </xs:complexType>`);
      } else {
        if (hasText){
          lines.push(`${pad}  <xs:complexType>`);
          lines.push(`${pad}    <xs:simpleContent>`);
          lines.push(`${pad}      <xs:extension base="${info.textType||TT.STR}">`);
          emitAttributes(info, ind+4);
          lines.push(`${pad}      </xs:extension>`);
          lines.push(`${pad}    </xs:simpleContent>`);
          lines.push(`${pad}  </xs:complexType>`);
        } else {
          lines.push(`${pad}  <xs:complexType>`);
          emitAttributes(info, ind+2);
          lines.push(`${pad}  </xs:complexType>`);
        }
      }
      lines.push(`${pad}</xs:element>`);
    }

    function normalizeOccurs(meta){
      const min = Math.max(meta?.min ?? 0, 0);
      const maxVal = meta?.max ?? 1;
      const max = Number.isFinite(maxVal) ? String(maxVal) : 'unbounded';
      return {min:String(min), max};
    }

    function orderByAppearance(info, names){
      const base = info.appearanceOrder || [];
      return [...names].sort((a,b)=>{
        const ia = base.indexOf(a);
        const ib = base.indexOf(b);
        if (ia === -1 && ib === -1) return a.localeCompare(b);
        if (ia === -1) return 1;
        if (ib === -1) return -1;
        return ia - ib;
      });
    }

    function deriveOrder(info){
      const names = [...info.children.keys()];
      if (!names.length) return [];
      const graph = new Map();
      const indegree = new Map();
      for (const name of names){
        graph.set(name, new Set());
        indegree.set(name, 0);
      }
      for (const [from, tos] of info.edges.entries()){
        if (!graph.has(from)) continue;
        for (const to of tos){
          if (!graph.has(to)) continue;
          const set = graph.get(from);
          if (!set.has(to)){
            set.add(to);
            indegree.set(to, indegree.get(to)+1);
          }
        }
      }
      const queue = [];
      const appearance = info.appearanceOrder || [];
      for (const [name,deg] of indegree.entries()){
        if (deg===0) queue.push(name);
      }
      queue.sort((a,b)=>{
        const ia = appearance.indexOf(a);
        const ib = appearance.indexOf(b);
        if (ia === -1 && ib === -1) return a.localeCompare(b);
        if (ia === -1) return 1;
        if (ib === -1) return -1;
        return ia - ib;
      });
      const result = [];
      while (queue.length){
        const name = queue.shift();
        result.push(name);
        for (const to of graph.get(name) || []){
          const nd = indegree.get(to)-1;
          indegree.set(to, nd);
          if (nd===0){
            queue.push(to);
            queue.sort((a,b)=>{
              const ia = appearance.indexOf(a);
              const ib = appearance.indexOf(b);
              if (ia === -1 && ib === -1) return a.localeCompare(b);
              if (ia === -1) return 1;
              if (ib === -1) return -1;
              return ia - ib;
            });
          }
        }
      }
      return result.length === names.length ? result : null;
    }

    function emitChildren(path, info, indent){
      const entries = [...info.children.entries()];
      if (!entries.length) return;
      const pad = '  '.repeat(indent);
      const order = deriveOrder(info);
      const useSequence = order && !info.hasSplitRuns;
      if (useSequence){
        lines.push(`${pad}<xs:sequence>`);
        for (const name of order){
          const meta = info.children.get(name);
          emitElement(`${path}/${name}`, indent+1, normalizeOccurs(meta));
        }
        lines.push(`${pad}</xs:sequence>`);
        return;
      }
      const allMaxOne = entries.every(([,meta]) => (meta?.max ?? 1) <= 1);
      if (!info.hasSplitRuns && allMaxOne){
        lines.push(`${pad}<xs:all>`);
        for (const name of orderByAppearance(info, entries.map(([n])=>n))){
          const meta = info.children.get(name);
          const min = meta?.min > 0 ? 1 : 0;
          emitElement(`${path}/${name}`, indent+1, {min:String(min), max:'1'});
        }
        lines.push(`${pad}</xs:all>`);
        return;
      }
      const hasSeqs = info.seqCount > 0;
      const allHaveChildren = hasSeqs && info.emptySeqCount === 0;
      const maxLen = hasSeqs ? info.maxSeqLen : 0;
      const choiceMin = allHaveChildren ? '1' : '0';
      const choiceMax = maxLen > 0 ? String(maxLen) : '1';
      lines.push(`${pad}<xs:choice minOccurs="${choiceMin}" maxOccurs="${choiceMax}">`);
      for (const name of orderByAppearance(info, entries.map(([n])=>n))){
        const meta = info.children.get(name);
        emitElement(`${path}/${name}`, indent+1, normalizeOccurs(meta));
      }
      lines.push(`${pad}</xs:choice>`);
    }

    function emitAttributes(info, indent){
      if (!info.attrs.size) return;
      const pad = '  '.repeat(indent);
      for (const [an, aMeta] of info.attrs.entries()){
        const type = aMeta.type || TT.STR;
        const required = aMeta.count === info.count && !(opt.nil && aMeta.seenEmpty);
        const use = required ? 'required' : 'optional';
        lines.push(`${pad}<xs:attribute name="${esc(an)}" type="${type}" use="${use}"/>`);
      }
    }
  }

  function refreshStats(){
    if (!model){ els.badgeRoot.textContent = 'Корневой элемент: —'; els.badgeNodes.textContent='Тегов: 0'; els.badgeAttrs.textContent='Атрибутов: 0'; els.badgeDepth.textContent='Глубина: 0'; return; }
    let root = '—';
    let attrs = 0;
    let depth = 1;
    let idx = 0;
    for (const n of model.values()){
      if (idx===0) root = n.name;
      attrs += n.attrs.size;
      if ((n.maxDepth||1) > depth) depth = n.maxDepth||1;
      idx++;
    }
    els.badgeRoot.textContent = 'Корневой элемент: ' + root;
    els.badgeNodes.textContent = 'Тегов: ' + model.size;
    els.badgeAttrs.textContent = 'Атрибутов: ' + attrs;
    els.badgeDepth.textContent = 'Глубина: ' + depth;
  }

  // ====== ЗАГРУЗКА ФАЙЛА + АВТО-РАЗБОР + АВТО-ГЕНЕРАЦИЯ ======
  async function handleLoadedText(text, filename){
    els.badgeFile.textContent = 'Файл: ' + (filename || '[без имени]');
    els.xml.value = text;
    els.btnParse.disabled = false;         // можно парсить вручную
    els.btnGen.disabled = true;            // до явного/авторазбора выключена

    // авто-разбор
    try{
      const parser = new DOMParser();
      xmlDoc = parser.parseFromString(text || '', 'application/xml');
      const perr = xmlDoc.getElementsByTagName('parsererror')[0];
      if (perr) throw new Error('Синтаксическая ошибка XML.');
      model = buildModel(xmlDoc);
      refreshStats();
      els.btnGen.disabled = false;         // после разбора включаем генерацию
      // авто-генерация
      const schema = emitXsd(model);
      els.xsd.value = schema;
      els.btnCopy.disabled = false; els.btnDownload.disabled = false;
      showOk('XML загружен, разобран и XSD сгенерирован.');
    }catch(err){
      model = null;
      els.btnGen.disabled = true;
      showErr(err.message || 'Ошибка разбора XML.');
    }
  }

  // ====== DnD на верхнюю дроп-зону ======
  els.drop.addEventListener('dragover', e => { e.preventDefault(); els.drop.classList.add('drag'); });
  els.drop.addEventListener('dragleave', () => els.drop.classList.remove('drag'));
  els.drop.addEventListener('drop', async e => {
    e.preventDefault(); els.drop.classList.remove('drag');
    const f = e.dataTransfer.files?.[0]; if (!f) return;
    if (!/\.xml$/i.test(f.name)){ showErr('Ожидается файл .xml'); return; }
    clearMsg(); setBusy(true);
    try{
      const text = await f.text();
      await handleLoadedText(text, f.name);
    }finally{ setBusy(false); }
  });

  // ====== DnD прямо в окно "Входной XML" (требование №1) ======
  els.xml.addEventListener('dragover', e => { e.preventDefault(); els.xml.classList.add('dragover'); });
  els.xml.addEventListener('dragleave', () => els.xml.classList.remove('dragover'));
  els.xml.addEventListener('drop', async e => {
    e.preventDefault(); els.xml.classList.remove('dragover');
    const f = e.dataTransfer.files?.[0];
    if (f){
      if (!/\.xml$/i.test(f.name)){ showErr('Ожидается файл .xml'); return; }
      clearMsg(); setBusy(true);
      try{
        const text = await f.text();
        await handleLoadedText(text, f.name);
      }finally{ setBusy(false); }
    } else {
      // если перетащили просто текст
      const text = e.dataTransfer.getData('text/plain');
      if (text){ await handleLoadedText(text, '[вставка текста]'); }
    }
  });

  // ====== Выбор файла диалогом ======
  els.file.addEventListener('change', async e => {
    const f = e.target.files?.[0]; if (!f) return;
    clearMsg(); setBusy(true);
    try{
      const text = await f.text();
      await handleLoadedText(text, f.name);
    }finally{ setBusy(false); }
  });

  // ====== Очистить ======
  els.btnClear.addEventListener('click', () => {
    els.xml.value = ''; els.xsd.value = '';
    xmlText = ''; xmlDoc=null; model=null;
    els.btnParse.disabled = true;
    els.btnGen.disabled = true;                 // требование №2: до разбора — недоступна
    els.btnCopy.disabled = true; els.btnDownload.disabled = true;
    els.badgeFile.textContent = 'Файл: —'; els.badgeRoot.textContent='Корневой элемент: —';
    els.badgeNodes.textContent='Тегов: 0'; els.badgeAttrs.textContent='Атрибутов: 0'; els.badgeDepth.textContent='Глубина: 0';
    clearMsg();
  });

  // ====== Разобрать XML (вручную) ======
  els.btnParse.addEventListener('click', () => {
    clearMsg(); setBusy(true);
    try{
      xmlText = els.xml.value || '';
      if (!xmlText.trim()){ showErr('Нет XML для разбора.'); setBusy(false); return; }
      const parser = new DOMParser();
      xmlDoc = parser.parseFromString(xmlText, 'application/xml');
      const perr = xmlDoc.getElementsByTagName('parsererror')[0];
      if (perr) throw new Error('Синтаксическая ошибка XML.');
      model = buildModel(xmlDoc);
      refreshStats();
      els.btnGen.disabled = false;              // после нажатия "Разобрать" — включаем (требование №2)
      showOk('XML разобран. Можно генерировать XSD.');
    }catch(err){
      showErr(err.message || 'Ошибка разбора XML.');
      model = null; els.btnGen.disabled = true;
    }finally{ setBusy(false); }
  });

  // ====== Сгенерировать XSD ======
  els.btnGen.addEventListener('click', () => {
    clearMsg(); setBusy(true);
    try{
      if (!model){ showErr('Сначала разберите XML.'); setBusy(false); return; }
      const schema = emitXsd(model);
      els.xsd.value = schema;
      els.btnCopy.disabled = false; els.btnDownload.disabled = false;
      showOk('Схема сгенерирована.');
    }catch(err){
      showErr('Ошибка генерации XSD.');
    }finally{ setBusy(false); }
  });

  // ====== Копирование / скачивание ======
  els.btnCopy.addEventListener('click', async () => {
    const s = els.xsd.value.trim(); if (!s) return;
    try{ await navigator.clipboard.writeText(s); showOk('Скопировано в буфер обмена.'); }
    catch(_){ showErr('Не удалось скопировать.'); }
  });
  els.btnDownload.addEventListener('click', () => {
    const s = els.xsd.value.trim(); if (!s) return;
    const blob = new Blob([s], {type:'application/xml;charset=utf-8'});
    const a = document.createElement('a');
    const stamp = new Date().toISOString().replaceAll(':','-').split('.')[0];
    a.href = URL.createObjectURL(blob);
    a.download = `schema_${stamp}.xsd`;
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },0);
  });

})();
</script>

</body>
</html>

